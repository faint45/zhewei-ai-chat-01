{
  "model": "qwen3:32b",
  "challenge": "分散式滑動窗口限流器（難度 8/10）",
  "elapsed_sec": 235.2,
  "tok_per_sec": 11.1,
  "response_length": 6577,
  "response": "```python\nimport asyncio\nimport logging\nimport time\nimport redis\nimport redis.asyncio as aioredis\nfrom typing import Optional, Dict, Any, Callable\nfrom fastapi import FastAPI, Request, HTTPException\nfrom fastapi.middleware.base import BaseHTTPMiddleware\nfrom contextlib import asynccontextmanager\nfrom dataclasses import dataclass\nfrom datetime import timedelta\nimport json\nimport threading\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# Tenant rate limits configuration\nTENANT_LIMITS = {\n    \"free\": 60,      # 60 requests per minute\n    \"pro\": 600,      # 600 requests per minute\n    \"enterprise\": 6000  # 6000 requests per minute\n}\n\n@dataclass\nclass RateLimitConfig:\n    window_seconds: int = 60\n    check_interval: int = 10  # Redis health check interval\n\nclass RedisHealthProbe:\n    def __init__(self, redis_client: aioredis.Redis, config: RateLimitConfig):\n        self.redis_client = redis_client\n        self.config = config\n        self.is_healthy = True\n        self.lock = threading.Lock()\n        self._stop_event = threading.Event()\n        self._thread = threading.Thread(target=self._monitor, daemon=True)\n\n    def start(self):\n        self._thread.start()\n\n    def stop(self):\n        self._stop_event.set()\n        self._thread.join()\n\n    def _monitor(self):\n        while not self._stop_event.is_set():\n            try:\n                self.redis_client.ping()\n                with self.lock:\n                    self.is_healthy = True\n            except Exception as e:\n                logger.error(f\"Redis health check failed: {e}\")\n                with self.lock:\n                    self.is_healthy = False\n            time.sleep(self.config.check_interval)\n\nclass SlidingWindowRateLimiter:\n    def __init__(self, redis_url: str, config: RateLimitConfig):\n        self.redis_url = redis_url\n        self.config = config\n        self.redis_pool = aioredis.ConnectionPool.from_url(redis_url)\n        self.redis_client = aioredis.Redis(connection_pool=self.redis_pool)\n        self.local_limiter = LocalSlidingWindowRateLimiter()\n        self.health_probe = RedisHealthProbe(self.redis_client, self.config)\n        self.health_probe.start()\n        \n        # Initialize LUA script\n        self.lua_script = self.redis_client.register_script(\"\"\"\n        local key = KEYS[1]\n        local now = tonumber(ARGV[1])\n        local window = tonumber(ARGV[2])\n        \n        -- Remove old entries\n        redis.call('ZREMRANGEBYSCORE', key, 0, now - window)\n        \n        -- Add new entry\n        redis.call('ZADD', key, now, now)\n        \n        -- Count requests in window\n        local count = redis.call('ZCARD', key)\n        \n        return count\n        \"\"\")\n        \n    async def is_allowed(self, tenant_id: str, limit: int) -> bool:\n        if self.health_probe.is_healthy:\n            return await self._distributed_is_allowed(tenant_id, limit)\n        else:\n            return self.local_limiter.is_allowed(tenant_id, limit)\n            \n    async def _distributed_is_allowed(self, tenant_id: str, limit: int) -> bool:\n        key = f\"rate_limit:{tenant_id}\"\n        now = time.time()\n        \n        try:\n            count = self.lua_script(\n                keys=[key],\n                args=[now, self.config.window_seconds]\n            )\n            \n            return count <= limit\n        except Exception as e:\n            logger.error(f\"Redis error: {e}. Falling back to local limiter.\")\n            self.health_probe.is_healthy = False\n            return self.local_limiter.is_allowed(tenant_id, limit)\n\nclass LocalSlidingWindowRateLimiter:\n    def __init__(self):\n        self.window_seconds = 60\n        self.limits: Dict[str, Dict] = {}\n        \n    def is_allowed(self, tenant_id: str, limit: int) -> bool:\n        now = time.time()\n        window = self.limits.setdefault(tenant_id, {\n            'window': now,\n            'requests': []\n        })\n        \n        # Remove old requests\n        window['requests'] = [t for t in window['requests'] if t > now - self.window_seconds]\n        \n        if len(window['requests']) >= limit:\n            return False\n            \n        window['requests'].append(now)\n        return True\n\nclass RateLimitMiddleware(BaseHTTPMiddleware):\n    def __init__(self, app: FastAPI, limiter: SlidingWindowRateLimiter):\n        super().__init__(app)\n        self.limiter = limiter\n        \n    async def dispatch(self, request: Request, call_next: Callable):\n        tenant_id = self._get_tenant_id(request)\n        limit = self._get_tenant_limit(tenant_id)\n        \n        if not await self.limiter.is_allowed(tenant_id, limit):\n            raise HTTPException(status_code=429, detail=\"Too Many Requests\")\n            \n        response = await call_next(request)\n        return response\n        \n    def _get_tenant_id(self, request: Request) -> str:\n        # In real implementation, extract tenant ID from headers, JWT, etc.\n        # For demo, using a query parameter\n        return request.query_params.get(\"tenant\", \"free\")\n        \n    def _get_tenant_limit(self, tenant_id: str) -> int:\n        return TENANT_LIMITS.get(tenant_id, 60)\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # Startup\n    redis_url = \"redis://localhost:6379\"\n    config = RateLimitConfig()\n    limiter = SlidingWindowRateLimiter(redis_url, config)\n    app.state.limiter = limiter\n    \n    yield\n    \n    # Shutdown\n    app.state.limiter.health_probe.stop()\n    await app.state.limiter.redis_client.close()\n    await app.state.limiter.redis_pool.disconnect()\n\ndef create_app() -> FastAPI:\n    app = FastAPI(lifespan=lifespan)\n    \n    # Add middleware\n    app.add_middleware(RateLimitMiddleware, limiter=app.state.limiter)\n    \n    @app.get(\"/test\")\n    async def test_endpoint():\n        return {\"status\": \"success\"}\n        \n    return app\n\nif __name__ == \"__main__\":\n    import uvicorn\n    app = create_app()\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n```\n\n### 技術解釋\n\n1. **滑動窗口 vs 令牌桶**:\n   - 滑動窗口能精確控制時間窗口內的請求數量，適合需要嚴格遵守速率限制的場景（如 API 訂閱計劃）\n   - 令牌桶允許一定程度的突發流量，適合需要流量整形的場景\n   - 本實現選擇滑動窗口是因為它能更精確地符合「每分鐘最多 X 次請求」的業務需求\n\n2. **高併發競態條件避免**:\n   - 使用 Redis 的 LUA 腳本確保操作的原子性（ZADD + ZREMRANGEBYSCORE + ZCARD 三步驟一次性執行）\n   - 本地限流器使用不可變資料結構操作（列表推導式過濾舊請求）\n   - Redis 健康探針使用獨立執行緒避免阻塞主流程\n\n3. **Redis LUA 原子性保證**:\n   - Redis 的 LUA 腳本執行時是串行的，不會被其他客戶端中斷\n   - 通過 `EVAL` 命令將多個 Redis 操作打包執行，確保中間狀態對其他客戶端不可見\n   - 即使在高併發場景下，也能保證每個請求的限流判斷基於一致的資料狀態\n\n這個實現完整支援：\n- 分散式精確滑動窗口限流（Redis）\n- 降級到本地限流（記憶體）\n- 自動 Redis 健康探測與切換\n- 多租戶動態限額\n- FastAPI 中間件整合\n- 完整異步支援與錯誤處理\n- 類型提示與日誌記錄",
  "timestamp": "2026-02-28 01:47:30"
}